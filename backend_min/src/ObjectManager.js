let cRef=require("./DBManager").cRef;const util={select:{compare:(a,b,c)=>{switch(b){case"<":return a<c;case">":return a>c;case"<=":return a<=c;case">=":return a>=c;case"==":return a==c;case"!=":return a!=c;case"has":return a.includes(c);case"!has":return!a.includes(c);default:throw new TypeError("Unkown comparator "+b);}},all:(...a)=>b=>{let c=b.data();c.defer&&(c.defer=c.defer.seconds),c.due&&(c.due=c.due.seconds);for(let[d,e,f]of a)if(!util.select.compare(c[d],e,f))return!1;return!0},any:(...a)=>b=>{let c=b.data();c.defer&&(c.defer=c.defer.seconds),c.due&&(c.due=c.due.seconds);for(let[d,e,f]of a)if(util.select.compare(c[d],e,f))return!0;return!1},atLeast:(a,...b)=>c=>{let d=c.data();d.defer&&(d.defer=d.defer.seconds),d.due&&(d.due=d.due.seconds);let e=0;for(let[f,g,h]of b)if(util.select.compare(d[f],g,h)&&(++e,e>=a))return!0;return!1},atMost:(a,...b)=>c=>{let d=c.data();d.defer&&(d.defer=d.defer.seconds),d.due&&(d.due=d.due.seconds);let e=0;for(let[f,g,h]of b)if(util.select.compare(d[f],g,h)&&(++e,e>a))return!1;return!0}},debug:{log:a=>(console.log(a),a),trace:a=>(console.trace(a),a)}};async function getTasks(a){return cRef("users",a,"tasks").get().then(a=>a.docs.map(a=>a.id)).catch(a=>{console.error("Error getting documents",a)})}async function getTasksWithQuery(a,b){let c=await cRef("users",a,"tasks").get().then(a=>a.docs.filter(b)).catch(a=>{console.error("Error getting documents",a)});return c.map(a=>a.id)}async function getInboxTasks(a){let b=await cRef("users",a,"tasks").get().then(a=>a.docs.filter(util.select.all(["project","==",""],["isComplete","==",!1])).sort((c,a)=>c.data().order-a.data().order)).catch(a=>{console.error("Error getting documents",a)});return b.map(a=>a.id)}async function getDSTasks(a,b){let c=new Date;c.setHours(c.getHours()+24);let d=await cRef("users",a,"tasks").get().then(a=>a.docs.filter(a=>!!a.data().due&&a.data().due.seconds<=c.getTime()/1e3&&(!a.data().defer||a.data().defer.seconds<new Date().getTime()/1e3)&&!1===a.data().isComplete&&b[a.id]).sort((c,a)=>c.data().due.seconds-a.data().due.seconds)).catch(console.error);return d.map(a=>a.id)}async function getInboxandDS(a,b){let c=await getInboxTasks(a),d=await getDSTasks(a,b),e=d.filter(a=>0>c.indexOf(a));return[c,e]}async function getTaskInformation(a,b){return(await cRef("users",a,"tasks").get().then(a=>a.docs.filter(a=>a.id===b)))[0].data()}async function removeParamFromTask(a,b,c){let d=await getTaskInformation(a,b);delete d[c],await cRef("users",a,"tasks",b).set(d).catch(console.error)}async function getTopLevelProjects(a){let b={},c={},d=[],e=await cRef("users",a,"projects").get();return e.docs.forEach(a=>{if(a.exists&&!0===a.data().top_level){c[a.id]=a.data().name,b[a.data().name]=a.id;let e={};e.id=a.id,e.name=a.data().name,e.sortOrder=a.data().order,d.push(e)}}),d.sort((c,a)=>c.sortOrder-a.sortOrder),[c,b,d]}async function getProjectsandTags(a){let b={},c={};await cRef("users",a,"projects").get().then(a=>a.docs.forEach(a=>{a.exists&&(c[a.id]=a.data().name,b[a.data().name]=a.id)})).catch(console.error);let d={},e={};return await cRef("users",a,"tags").get().then(a=>a.docs.forEach(a=>{a.exists&&(e[a.id]=a.data().name,d[a.data().name]=a.id)})).catch(console.error),[[c,b],[e,d]]}async function getPerspectives(a){let b={},c={},d=[];return await cRef("users",a,"perspectives").get().then(a=>a.docs.forEach(a=>{a.exists&&(c[a.id]={name:a.data().name,query:a.data().query,avail:a.data().avail,tord:a.data().tord},b[a.data().name]={id:a.id,query:a.data().query,avail:a.data().avail,tord:a.data().tord},d.push({id:a.id,...a.data()}))})).catch(console.error),d.sort((c,a)=>c.order-a.order),[c,b,d]}async function modifyProject(a,b,c){await cRef("users",a,"projects",b).update(c).catch(console.error)}async function modifyTask(a,b,c){await cRef("users",a,"tasks",b).update(c).catch(console.error)}async function modifyPerspective(a,b,c){await cRef("users",a,"perspectives",b).update(c).catch(console.error)}async function newTask(a,b){if(""===b.project){let c=(await getInboxTasks(a)).length;b.order=c}else{let c=(await getProjectStructure(a,b.project)).children.length;b.order=c}return b.defer||(b.defer=new Date),(await cRef("users",a,"tasks").add(b)).id}async function newProject(a,b,c){let d;return Object.size=function(a){var b,c=0;for(b in a)a.hasOwnProperty(b)&&c++;return c},c?(d=(await getProjectStructure(a,c)).children.length,b.parent=c):(d=Object.size((await getTopLevelProjects(a))[0]),b.parent=""),b.order=d,b.children={},(await cRef("users",a,"projects").add(b)).id}async function newPerspective(a,b){return(await cRef("users",a,"perspectives").add({order:(await getPerspectives(a))[2].length,...b})).id}async function newTag(a,b){return(await cRef("users",a,"tags").add({name:b})).id}async function completeTask(a,b){await cRef("users",a,"tasks",b).update({isComplete:!0})}async function dissociateTask(a,b,c){let d=await cRef("users",a,"projects").get().then(util.dump).then(a=>a.docs.filter(a=>a.id===c)).then(util.dump).then(a=>a[0].data().children);delete d[b],await cRef("users",a,"projects",c).update({children:d})}async function associateTask(a,b,c){let d=await cRef("users",a,"projects").get().then(a=>a.docs.filter(a=>a.id===c)[0].data().children);d[b]="task",await cRef("users",a,"projects",c).update({children:d})}async function associateProject(a,b,c){let d=await cRef("users",a,"projects").get().then(a=>a.docs.filter(a=>a.id===c)[0].data().children);d[b]="project",await cRef("users",a,"projects",c).update({children:d})}async function dissociateProject(a,b,c){let d=await cRef("users",a,"projects").get().then(util.dump).then(a=>a.docs.filter(a=>a.id===c)).then(util.dump).then(a=>a[0].data().children);delete d[b],await cRef("users",a,"projects",c).update({children:d})}async function deleteTask(a,b,c=!0){let d=await cRef("users",a,"tasks").get().then(a=>a.docs.filter(a=>a.id===b)[0].data());""!==d.project&&c&&(await dissociateTask(a,b,d.project)),await cRef("users",a,"tasks",b).delete().catch(console.error)}async function deletePerspective(a,b){await cRef("users",a,"perspectives",b).delete()}async function deleteProject(a,b){getProjectStructure(a,b).then(async function(c){for(let b of c.children)"project"===b.type?deleteProject(a,b.content.id):modifyTask(a,b.content,{project:""});await cRef("users",a,"projects",b).delete().catch(console.error)})}async function deleteTag(a,b){await cRef("users",a,"tags",b).delete().catch(console.error)}async function getProjectStructure(a,b,c=!1){let d=[],e=(await cRef("users",a,"projects").get().then(a=>a.docs)).filter(a=>a.id===b)[0];for(let[f,g]of Object.entries(e.data().children))if("task"===g){let b=await getTaskInformation(a,f);b.isComplete||d.push({type:"task",content:f,sortOrder:b.order})}else if("project"===g)if(c){let b=await getProjectStructure(a,f);d.push({type:"project",content:b,is_sequential:b.is_sequential,sortOrder:b.sortOrder})}else{let b=(await cRef("users",a,"projects").get().then(a=>a.docs)).filter(a=>a.id===f)[0];d.push({type:"project",content:{id:f},is_sequential:b.data().is_sequential,sortOrder:b.data().order})}return d.sort((c,a)=>c.sortOrder-a.sortOrder),{id:b,children:d,is_sequential:e.data().is_sequential,sortOrder:e.data().order,parentProj:e.data().parent}}async function getItemAvailability(a){async function recursivelyGetBlocks(a,b){let c={},d=(await cRef("users",a,"projects").get().then(a=>a.docs)).filter(a=>a.id===b)[0],e=await getProjectStructure(a,b);if(d.data().is_sequential){let b=e.children[0];b&&("project"===b.type?(Object.assign(c,await recursivelyGetBlocks(a,b.content.id)),c[b.content.id]=!0):"task"===b.type&&(c[b.content]=!0))}else{let b=e.children;await Promise.all(b.map(async function(b){"project"===b.type?(Object.assign(c,await recursivelyGetBlocks(a,b.content.id)),c[b.content.id]=!0):"task"===b.type&&(c[b.content]=!0)}))}return c}let b=new Date,c=(await getTopLevelProjects(a))[2],d={},e=new Date;return await Promise.all(c.map(async function(b){d[b.id]=!0;let c=await recursivelyGetBlocks(a,b.id);Object.assign(d,c)})),await(await getInboxTasks(a)).forEach(a=>d[a]=!0),d}module.exports={util,getTasks,getTasksWithQuery,getInboxTasks,getDSTasks,getInboxandDS,removeParamFromTask,getTopLevelProjects,getProjectsandTags,getPerspectives,modifyProject,modifyTask,modifyPerspective,newProject,newPerspective,newTag,newTask,completeTask,dissociateTask,associateTask,associateProject,dissociateProject,deleteTask,deletePerspective,deleteProject,getProjectStructure,getItemAvailability,getTaskInformation};